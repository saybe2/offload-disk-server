# ТЗ: Облачное хранилище на базе Discord (стадия планирования)

## 1) Цель
Создать сервис «облачного хранилища», который использует Discord как физическое хранилище архивов. Пользователь загружает файлы через веб‑интерфейс; файлы сначала сохраняются локально (кэш/стейджинг) для высокой скорости, затем асинхронно архивируются, шифруются, нарезаются на части и загружаются в Discord через пул вебхуков. Сервис позволяет восстановить исходные данные по метаданным.

## 1.1) Базовые решения (приняты)
- Стек: Node.js + TypeScript (сервер, API, воркеры).
- База данных: MongoDB (удалённая).
- Хранилище структуры и метаданных: только БД, в Discord хранится только файл.
- Шифрование: ключ хранится в БД и дублируется в ENV (резерв для ручного восстановления).
- Веб‑интерфейс обязателен, multi‑user.
- Кэш: файлы удаляются сразу после успешной загрузки в Discord.
- Пул вебхуков: ~5 на старте, с возможностью расширения.
- Аутентификация: логин/пароль, роли (админ/пользователь).
- Webhook URL хранятся в БД в открытом виде (как принято сейчас).
- Фактический лимит webhook (тест 2026‑02‑01): 9.8 MiB проходит, 10 MiB не проходит.
- Размер чанка по умолчанию: 9.8 MiB (настраиваемо).
- Политика дискового давления: мягкие лимиты (снижение параллелизма и/или прямой режим без длительного кэша).

## 2) Область применения и ограничения
- Используется Discord как внешнее хранилище объектов (attachments).
- Сервис не является публичным файловым хостингом.
- Использование Discord должно соответствовать актуальным правилам платформы.
- Сервис не рассчитан на хранение особо чувствительных данных без шифрования.

## 3) Основные сценарии
- Загрузка (backup): пользователь загружает файлы через веб‑UI → файлы сохраняются в локальный стейджинг → создаётся задача в очереди → (если несколько файлов) упаковка в zip → шифрование → нарезка → отправка в Discord через пул вебхуков → запись метаданных.
- Восстановление (restore): пользователь скачивает файл → сервер стримит сборку из частей Discord → проверка целостности → расшифровка на лету → выдача пользователю.
- Просмотр каталога: список файлов, их статусов (в очереди/загружается/готов), даты и прогресса.
- Корзина: удаление в корзину, авто‑удаление через 30 дней или вручную.
- Папки: вложенные папки, создание папок и перемещение файлов, просмотр размера папки.
- Удаление: удаление метаданных, очистка локального кэша и удаление сообщений/файлов в Discord.
- Контекстное меню: быстрые действия (скачать, удалить, инфо, приоритет).

## 4) Функциональные требования
- Веб‑интерфейс: загрузка файлов/папок, отображение прогресса и статусов задач.
- Локальный кэш/стейджинг: быстрый приём загрузок, хранение до выгрузки в Discord.
- Очередь задач и фоновые воркеры для архивации/загрузки/восстановления.
- Архивирование данных в единый формат (zip/7z/tar).
- Шифрование по умолчанию (например, AES-256) на стороне сервиса перед отправкой в Discord.
- Разбиение архивов на части, размер которых не превышает лимиты Discord.
- Отправка через пул вебхуков для распределения нагрузки и повышения суммарной пропускной способности.
- Хранение метаданных (манифест) в локальной БД и/или в отдельном канале Discord.
- Проверка целостности (хеши для каждой части + общий хеш архива).
- Повторная отправка при ошибках загрузки + экспоненциальные ретраи.
- Логирование операций и аудит задач.
- Управление пулом вебхуков (добавление/отключение/ротация).
- Управление пользователями и доступами (multi‑user).
- Управление квотами: админ задаёт лимиты на пользователя (объём/кол-во архивов), с возможностью изменения.
- Контроль дискового давления: при нехватке места снижать параллелизм и/или переключаться на прямую отправку в Discord без длительного кэширования.
- Настраиваемый размер части (chunk size) с возможностью тестового определения лимита на сервере.
- Корзина: файлы удаляются логически, физическое удаление через 30 дней или по явному запросу.
- Задачи удаления выполняются только когда нет очереди загрузки.
- Папки и перетаскивание файлов между папками.
- Вложенные папки (дерево), дубликаты имён допускаются в разных родителях.
- Приоритеты: на уровне файлов и папок (lowest → maximum), влияет на очередь загрузки.
- Прогресс удаления отображается в корзине.
- Правый клик по файлу/папке с кастомными действиями.
- Поиск по списку файлов.
- Отображение файлов внутри bundle как отдельных строк (скачивание отдельных файлов из bundle).

## 5) Нефункциональные требования
- Надёжность: возможность восстановить архив при частичном сбое и повторно догрузить части.
- Безопасность: шифрование по умолчанию, защита ключей, ограничение доступа к веб‑UI.
- Масштабирование: поддержка большого количества архивов и частей.
- Производительность: потоковая отправка частей, без полной загрузки в память.
- Совместимость: развертывание на сервере Linux (64‑бит).
- Ресурсы: 100 ГБ диск, 4 ГБ RAM (при необходимости масштабируемо), CPU 56 ядер.
- Устойчивость к рестарту: незавершённые загрузки продолжаются после перезапуска сервера.

## 6) Архитектура
- Веб‑приложение: UI + API для загрузки/просмотра/скачивания.
- Локальный стейджинг: каталог для временного хранения загрузок до отправки в Discord.
- Очередь задач: постановка задач на архивирование/отправку/восстановление.
- Фоновые воркеры: выполняют тяжёлые операции и обмен с Discord.
- Пул вебхуков Discord: несколько webhook URL для распределения нагрузок.
- Каналы Discord:
  - Канал хранения частей (payload).
  - Канал метаданных (manifest), опционально.
- БД метаданных: индекс архивов, частей, статусов, ссылок на сообщения и хешей.
 - Модуль шифрования: генерация ключей на архив, хранение в БД + резерв в ENV.
 - Конфигурация через ENV (например: MONGODB_URI, MASTER_KEY).

## 7) Формат манифеста
Для каждого архива хранится:
- Название, время создания, размер.
- Хеш архива.
- Список частей: порядок, размер, хеш, ссылка на сообщение Discord.
- Настройки шифрования (алгоритм, соль, параметры).
 - Состояние задачи (ожидает/в процессе/готово/ошибка).
 - Использованный webhook/канал.
 - Владелец (userId) и права доступа.

## 8) Риски и ограничения
- Discord не предназначен для хранения файлов, возможны ограничения и блокировки.
- Лимиты размера вложений зависят от уровня сервера/подписки.
- Скорость загрузки/скачивания может зависеть от ограничений Discord API.
- Риск потери данных при удалении сообщений или бане бота.
- Риск утечки webhook URL при хранении в открытом виде.
- Риск переполнения локального диска при больших очередях.
 - Неопределённость фактического лимита размера файла для webhook на конкретном сервере/уровне буста.

## 9) План реализации (по этапам)
1. Уточнение лимитов Discord и правила использования.
2. Проектирование архитектуры (web UI, очередь, воркеры, БД, стейджинг).
3. Проектирование схемы манифеста и статусов задач.
4. Прототипирование загрузки/скачивания через Discord вебхуки + тест на фактический лимит части.
5. Реализация архивации, нарезки, хеширования.
6. Реализация шифрования и управления ключами (ключ в БД + резерв в ENV).
7. Реализация очереди и фоновых воркеров, ретраи, контроль диска.
8. Реализация web UI и API, multi‑user и управление вебхуками.
9. Реализация восстановления из частей и выдачи пользователю.
10. Тестирование (малые/большие архивы, сбои, ретраи, переполнение диска).
11. Документация и релиз.

## 10) Открытые вопросы
 - Нет открытых вопросов на текущем этапе.

## 11) Критерии готовности (MVP)
- Можно загрузить файлы через web UI и получить задачу в очереди.
- Файлы архивируются, шифруются и загружаются в Discord через пул вебхуков.
- Можно скачать части и восстановить архив.
- Есть базовый журнал операций и статусы задач.
- Есть манифест с проверкой целостности.

## 12) Backlog / Идеи
- VLESS-проксирование трафика Discord на стороне offload-сервера (для upload/download частей), чтобы снять DPI-нагрузку с роутера и не проксировать весь домашний трафик.
- Варианты реализации:
  - системный route/tproxy только для Discord CIDR/доменов;
  - локальный outbound-прокси (xray sing-box) и проксирование HTTP-клиента приложения только для Discord запросов;
  - fallback-режим: direct -> proxy при таймаутах/ошибках.
- Важные метрики: средняя скорость upload/download, доля ошибок, загрузка CPU роутера до/после, влияние на latency API.
- Аналитика/наблюдаемость:
  - Proxy status в админке (xray up/down, активен ли fallback на direct, последние ошибки);
  - метрики очереди (queued/processing/ready/error), скорость обработки частей, среднее ETA;
  - метрики по источникам (Discord/Telegram): скорость, retry rate, error rate.
- Telegram fallback (бот/API) как резервный провайдер хранения:
  - провайдерная абстракция хранения (primary Discord, secondary Telegram);
  - fallback-чтение/запись при недоступности Discord;
  - селективное проксирование Telegram-трафика через тот же outbound proxy.

